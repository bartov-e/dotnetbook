## Архитектура изоляции

Как я уже говорил, нам нет никакой необходимости делать изоляцию по памяти: т.к. контроль над исполнением кода (путём его самостоятельной компиляции) даёт домену все возможности для контроля всего приложения. Но как это достигается? Домен - это некий изолирующий контейнер. Потому, если мы имеем дело с загружаемыми библиотеками, было бы логично если бы эти библиотеки загружались бы не в общее для всех место, а в эту песочницу.

Давайте рассмотрим пример с загрузкой экземпляра типа в два домена. Тогда при таком раскладе мы имеем один и тот же тип:

```csharp
class SomeType
{
    public int X { get; set; }
}
```

Который мы загрузим в оба домена, при этом мы получим дважды скомпилированный код. Что это будет означать? Что у экземпляров этих типов адрес таблицы виртуальных методов совпадать не будет:

```csharp
// В первом домене:
var x = new SomeType();
var handle1 = x.GetType().TypeHandle;

// Во втором домене:
var x = new SomeType();
var handle2 = x.GetType().TypeHandle;

// где-то в общем коде
Console.WriteLine(handle1 == handle2);
// --> false
```

Это значит что если мы получим каким-либо образом из второго домена ссылку на объект и в первом домене попробуем привести к типу `SomeHandle`, то ничего не получится: типы не совпадут. Ведь из-за того что таблицы виртуальных методов разные, то и типы будут считаться разными и не совместимыми. Получается, что загрузив код в разные домены вместо загрузки в некое междоменное пространство `CLR` строит первый барьер защиты. Второй барьер защиты: нам необходимо организовать взаимодействие между доменами: быть полностью изолированными - так себе возможности и хочется иметь не полную изоляцию, а контролируемое взаимодействие. Интереснее получать данные из плагина для неких расчётов или действий и получать результаты работы - назад. Это можно организовать при помощи системных (организованных JITом)прокси-методов, которые будут переносить данные между двумя несовместимыми типами (а по сут - одним и тем же типом, загруженным в разные домены). Посмотрим на пример такого вызова с использованием псевдокода:

```
TODO: изображение, поясняющее процесс взаимодействия между доменами
```

```csharp
// Мы получаем ссылку на объект из второго домена в первом
var objectFromSecondDomain = GetObjectFromSecondDomain();

// И пробуем вызвать метод (как мы это обычно делаем)
var data = objectFromSecondDomain.Method();

// Что происходит на самом деле:
// Вместо метода вызывается невидимый для нас прокси метод,
// объявленный где-то в CLR, а не в самом типе:
var data = _SomeType_MethodToDomainProxy_(objectFromSecondDomain);
private SomeType _SomeType_MethodToDomainProxy_()
{
    if(CurrentDomain == Domain2){
        return objectFromSecondDomain.Method();
    }

    // Который приводит ссылку к необходимому типу из второго домена
    var castedType = (SomeType_FromDomain2)(objectFromSecondDomain);

    // сохраняем ссылку на наш домен и выставляем Domain 2 как активный
    var priorDomain = CurrentDomain;
    CurrentDomain = Domain2;

    // вызывает метод
    var result = castedType.Method();

    // восстанавливаем ссылку на текущий домен
    CurrentDomain = priorDomain;

    // и проверяет объект, который возвращён из метода на безопасность
    if(!CLR.VerifyResultForSafety(result))
    {
        throw CLR.GetExceptionForUnsafeCall();
    }

    // если все хорошо, возвращает результат
    return result;
}
```

Хорошо: теперь мы знаем обо всех вызовах, которые происходят в системе. Однако, это накладывает огромные расходы: нам ведь каждый раз необходимо понимать, что мы вызываем метод именно в другом домене, а не в текущем. А таких вызовов будет большинство: междоменного взаимодействия очень мало. Значит, чтобы такие расходы ложились бы только на необходимо ввести некий специальный тип, при наследовании от которого CLR поймёт, что он будет участвовать в междоменном взаимодействии и создаст прокси-методы только для него. Тип этот - `MarshalByRefObject` и это решение также создаст ещё один барьер безопастности: вы не можете вызывать методы, скомпилированные для других доменов напрямую: только для `MarshalByRefObject` типов.

Что мы имеем на данный момент? Во-первых, если наш код загружен в два и более доменов, то скомпилирован он будет соответствующее число раз, а значит с точки зрения типов один и тот же тип, скомпилированных для нескольких доменов - это несколько разных типов. Далее, вводятся проверки для вызовов методов из одного домена в другой. Можно назвать это словом "таможня". При пересечении границы всё, что проходит через такую вот таможню должно досматриваться: этим действием контролируется, что все ограничения соблюдены. Ну и чтобы CLR понимала, какие типы могут участвовать во взаимодействии между доменами проходить границу могут не все типы, а только те, которые унаследовали `MarshalByRefObject`. Достаточно ли этого? Наверное, нет: мы отдаём в метод, скомпилированный для другого домена некую ссылку на свой объект, тот его принимает, но в другом домене работать с таким доменом нет никакой возможности: его система типов отлична и приведение типов работать не будет. Как тогда организовать взаимодействие?

Решения для такой проблематики два. Перовое решение - необходимо сделать так, чтобы передаваемые данные полностью бы отражали содержание объекта, но при этом не были бы самим объектом - раз. И при этом были бы достаточно простыми чтобы не представлять опасности - два. Такими данными яввяются сериализованные данные:

- При сериализации CLR превращает данные в некий формат. Т.е. мы не можем передать ссылку на объект, обладающий *повышенными* привилегиями в код, обладающий более низкими привилегиями;
- При десериализации мы можем сформировать объекты только из того что было передано через сериализованный объект. Ничего опасного мы оттуда получить не сможем именно благодаря процессу сериализации.

Второе решение - организовать средство повышенного доверия к передаваемым между доменами данным. Такого доверия, что можно не волнуясь отдавать без всякой сериализации и десериализации ссылки на объекты в соседний домен и не волноваться, что это как-то повлияет на безопасность. Чтобы решить эту задачу, был разработан FullTrust, который может быть применён к отдельным сборкам домена.

Касательно Shared AppDomains мы поговорим немного позже: слово за слово мне придётся написать о многих вопросах. А потому эта тема поставлена на временную паузу. Сейчас же попробуем обосновать, создали ли мы идеальную песочницу:

- Итак, для начала мы рассмотрели понятие домена как места, создающего изоляцию в вопросах исполнения кода. Внешние библиотеки загружаются отдельно в каждый их доменов и нет возможности кода одного домена работать с кодом другого нарямую, т.к. указатели на таблицы виртуальных методов (VMT) будут разными;
- Из-за этого возникает в некоторой степени изоляция по памяти: код `домена 1` не сможет работать с объектами, созданными в рамках `домена 2` по ранее указанной причине;
- Чтобы это обеспечить, между точкой вызова метода и его реальным вызовом встаёт прокси функция, которая проверяет параметры метода и возвращаемое значение на корректность, осуществляет маршиллинг и передачу данных через Remoting;
- Домены могут быть отгружены: вместе со всеми сборками, динамически скомпилированным кодом, а также всеми объектами, которые были созданы в рамках этого домена. Эта возможность - следствие изолированности домена друг от друга;
- Каждая подсистема домена может быть индивидуально разрешена или запрещена для исполнения кода в зависимости от настроек домена, выданных ему при старте приложения. Этот функционал расширяем и может быть дополнен настройками безопасности для ваших библиотек, которые будут использованы в этих доменах;
